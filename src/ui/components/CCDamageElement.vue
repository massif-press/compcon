<template>
  <div
    v-for="d in <Damage[]>damage"
    :class="`text-center d-inline-block pr-${dense || small ? '1' : '3'}`">
    <cc-tooltip :title="`${d.Value} ${typeOverride || d.Type} Damage`" :content="Help(d)">
      <span v-if="small">
        <v-icon :color="damageColor(d)" :icon="damageIcon(d)" class="mt-n1" />
        <v-icon v-if="d.Override" icon="mdi-information-outline" color="text" />
        <b v-else v-text="`${added ? '+' : ''}${d.Value}`" />
      </span>
      <v-row v-else align="center" no-gutters>
        <v-col cols="auto">
          <v-icon :size="dense ? 25 : 35" :color="damageColor(d)" :icon="damageIcon(d)" />
        </v-col>
        <v-col
          cols="auto"
          class="heading text-text mb-n2"
          :style="`font-size: ${dense ? '20' : '24'}pt;`">
          {{ `${added ? '+' : ''}${d.Value}` }}
        </v-col>
      </v-row>
    </cc-tooltip>
    <div v-if="!small" class="text-caption text-text text-uppercase">
      <b>{{ typeOverride ? typeOverride : d.Type }}</b>
    </div>
  </div>
</template>

<script lang="ts">
import { Damage } from '@/class';

export default {
  name: 'cc-damage-element',
  props: {
    damage: {
      type: Array,
      required: true,
      validator: (prop: Damage[]) => prop.every((dmg) => dmg instanceof Damage),
    },
    typeOverride: {
      type: String,
      required: false,
    },
    small: {
      type: Boolean,
    },
    added: {
      type: Boolean,
    },
    inline: {
      type: Boolean,
    },
    dense: {
      type: Boolean,
    },
  },
  data: () => ({
    dialog: false,
    availableTypes: [],
    selected: '',
  }),
  methods: {
    damageColor(d: Damage): string {
      return this.typeOverride ? `damage--${this.typeOverride.toLowerCase()}` : d.Color;
    },
    damageIcon(d: Damage): string {
      return this.typeOverride ? `cc:${this.typeOverride.toLowerCase()}` : d.Icon;
    },
    Help(d: Damage): string {
      switch (d.Type.toLowerCase()) {
        case 'heat':
          return `This equipment deals ${d.Value} ${d.Type} Damage<br><div class="text-overline text-disabled mb-n2 ">HEAT:</div>Heat is a special type of harm that doesn’t count as damage and ignores ARMOR, although it can be affected by RESISTANCE. It represents damage to a mech's internal systems and reactor. It's most often inflicted by electronic warfare, but is often generated by a mech’s own systems. When a mech reaches its HEAT CAP, any additional Heat causes it to overheat. If a character without a HEAT CAP (such as BIOLOGICAL characters and some DRONES) would take Heat, they instead take an equivalent amount of Energy damage.`;
        case 'burn':
          return `This equipment deals ${d.Value} ${d.Type} Damage<br><div class="text-overline text-disabled mb-n2 ">BURN:</div>Some weapons deal Burn (damage over time). Burn might represent flames, searing plasma, acid or something more insidious, like a swarm of greywash nanites. When characters take Burn, it has two effects: first, they immediately take Burn damage, ignoring ARMOR, and then they record Burn they just took. At the end of their turn, characters with Burn marked must roll an ENGINEERING check. On a success, they clear all burn currently marked; otherwise, they take Burn damage equal to the amount of Burn currently marked. Burn from additional sources adds to the total marked Burn.`;
        default:
          return `This equipment deals ${d.Value} ${d.Type} Damage`;
      }
    },
  },
};
</script>
